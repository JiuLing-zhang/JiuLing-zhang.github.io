<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>.NET on 码术-一个皇马球迷的博客而已</title>
    <link>https://jiuling.me/categories/.net/</link>
    <description>Recent content in .NET on 码术-一个皇马球迷的博客而已</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-CN</language>
    <lastBuildDate>Mon, 01 Mar 2021 21:54:13 +0800</lastBuildDate><atom:link href="https://jiuling.me/categories/.net/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C#基元线程同步构造</title>
      <link>https://jiuling.me/post/c-%E5%9F%BA%E5%85%83%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9E%84%E9%80%A0/</link>
      <pubDate>Mon, 01 Mar 2021 21:54:13 +0800</pubDate>
      
      <guid>https://jiuling.me/post/c-%E5%9F%BA%E5%85%83%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9E%84%E9%80%A0/</guid>
      <description>&lt;p&gt;&lt;strong&gt;基元&lt;/strong&gt;是指可以在代码中使用的最简单的构造。&lt;br&gt;
有两种基元构造：&lt;strong&gt;用户模式构造&lt;/strong&gt;和&lt;strong&gt;内核模式构造&lt;/strong&gt;。应尽量使用用户模式构造，它们的速度要比内核构造快很多，因为他们使用了特殊的&lt;code&gt;CPU&lt;/code&gt;指令来协调线程（意味着协调是在硬件中发生，所以会快很多）。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>C#托管堆和垃圾回收</title>
      <link>https://jiuling.me/post/c-%E6%89%98%E7%AE%A1%E5%A0%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</link>
      <pubDate>Fri, 05 Feb 2021 21:55:58 +0800</pubDate>
      
      <guid>https://jiuling.me/post/c-%E6%89%98%E7%AE%A1%E5%A0%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</guid>
      <description>&lt;h2 id=&#34;托管堆基础&#34;&gt;托管堆基础&lt;/h2&gt;
&lt;h3 id=&#34;分配资源&#34;&gt;分配资源&lt;/h3&gt;
&lt;p&gt;C#要求所有对象都从&lt;strong&gt;托管堆&lt;/strong&gt;分配。进程初始化时，&lt;code&gt;CLR&lt;/code&gt;划出一个地址空间区域作为托管堆。&lt;code&gt;CLR&lt;/code&gt;还会维护一个叫&lt;code&gt;NextObjPtr&lt;/code&gt;的指针，该指针指向下一个对象在堆中的位置。&lt;/p&gt;
&lt;p&gt;一个区域被非垃圾填满后，&lt;code&gt;CLR&lt;/code&gt;会分配更多的区域出来，一直重复，直到进程地址空间被填满。(32位进程最多能分配1.5GB;64位进程最多能分配8TB)&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
