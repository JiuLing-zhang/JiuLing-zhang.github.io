[{"content":"基元是指可以在代码中使用的最简单的构造。\n有两种基元构造：用户模式构造和内核模式构造。应尽量使用用户模式构造，它们的速度要比内核构造快很多，因为他们使用了特殊的CPU指令来协调线程（意味着协调是在硬件中发生，所以会快很多）。\n","lvl0":"C#基元线程同步构造","lvl1":[".NET"],"lvl2":"预览","objectID":"5654d693f845be60214e2ace6c9dc988","tags":["线程同步","Volatile"],"url":"https://jiuling.me/post/c-%E5%9F%BA%E5%85%83%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9E%84%E9%80%A0/"},{"content":"定义 为其他对象提供一个代理通道，来完成对这个对象的访问。\n类型 结构型模式\n特点 可以对调用者隐藏实际对象。\n举例 张三替李四追求王五。\n本文以C#为例，先来看类图🔻\n","lvl0":"设计模式-代理模式","lvl1":["设计模式"],"lvl2":"预览","objectID":"04f60abcc972e3ae3f272d55959896da","tags":["设计模式","代理模式","结构型模式","C#"],"url":"https://jiuling.me/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"content":"定义 策略模式实际上是定义了一系列算法，他们可以相互替换，但是并不影响算法的调用者。\n类型 行为型模式\n特点 算法可以相互替换，并不相互影响，具体算法也不会暴露给调用者。\n举例 超市结账时，使用不同的优惠方式进行结算。\n本文以C#为例，先来看类图🔻\n","lvl0":"设计模式-策略模式","lvl1":["设计模式"],"lvl2":"预览","objectID":"07dac2617fff508354541fb546e4559e","tags":["设计模式","策略模式","行为型模式","C#"],"url":"https://jiuling.me/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"},{"content":"定义 用单独一个类来创建具体实例的过程。\n类型 创建型模式\n特点 使用工厂可以减少代码的耦合性，使代码的可维护性变高。遇到新的需求时，只要新增一个功能的实现，然后通过工厂将实例构建出来即可。\n举例 实现两个数字的计算，运用工厂分别创建计算加、减、乘、除的不同实例。\n本文以C#为例，先来看类图🔻\n","lvl0":"设计模式-简单工厂模式","lvl1":["设计模式"],"lvl2":"预览","objectID":"0fa2092515c06df8fc1dd5c07dc735d4","tags":["设计模式","简单工厂模式","创建型模式","C#"],"url":"https://jiuling.me/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"},{"content":"起源 一切都要从那个线上bug说起，执行decimal.TryParse时程序并没有按照预期输出结果💔💔💔\n1 2 3 4 5 6 7 8 9 10 11  string input = \u0026#34;1,2,3\u0026#34;; decimal output; if (decimal.TryParse(input, out output)) { Console.WriteLine($\u0026#34;{output}\u0026#34;); } else { Console.WriteLine($\u0026#34;Unable to decimal {input}\u0026#34;); } //这里意外的输出了 123   ","lvl0":"C#使用decimal TryParse转换时，字符串中有逗号的坑","lvl1":["那些年里的那些坑"],"lvl2":"预览","objectID":"d3b8211159c37a26efe48ee55794ab16","tags":["C#"],"url":"https://jiuling.me/post/c-%E4%BD%BF%E7%94%A8decimal-tryparse%E8%BD%AC%E6%8D%A2%E6%97%B6%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%9C%89%E9%80%97%E5%8F%B7%E7%9A%84%E5%9D%91/"},{"content":"托管堆基础 分配资源 C#要求所有对象都从托管堆分配。进程初始化时，CLR划出一个地址空间区域作为托管堆。CLR还会维护一个叫NextObjPtr的指针，该指针指向下一个对象在堆中的位置。\n一个区域被非垃圾填满后，CLR会分配更多的区域出来，一直重复，直到进程地址空间被填满。(32位进程最多能分配1.5GB;64位进程最多能分配8TB)\n","lvl0":"C#托管堆和垃圾回收","lvl1":[".NET"],"lvl2":"预览","objectID":"185be7236020295951bc591fcd28fe9d","tags":[".NET","C#","垃圾回收"],"url":"https://jiuling.me/post/c-%E6%89%98%E7%AE%A1%E5%A0%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"}]