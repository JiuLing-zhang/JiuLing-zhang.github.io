<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>C#基元线程同步构造 - 码术-一个皇马球迷的博客而已</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="九零" /><meta name="description" content="我们都知道，程序在运行时，不同线程访问同一个对象，是非常常见的事情。这种情况下如果处理不当，那么就会造成与预期不符的结果，所以线程同步在程序里有着相当重要的作用。 下面我们来看下常用的一些线程同步的方式方法。🔻
" /><meta name="keywords" content="码术" />






<meta name="generator" content="Hugo 0.81.0 with theme even" />


<link rel="canonical" href="https://jiuling.me/post/c-%E5%9F%BA%E5%85%83%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9E%84%E9%80%A0/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css" integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin="anonymous">


<meta property="og:title" content="C#基元线程同步构造" />
<meta property="og:description" content="我们都知道，程序在运行时，不同线程访问同一个对象，是非常常见的事情。这种情况下如果处理不当，那么就会造成与预期不符的结果，所以线程同步在程序里有着相当重要的作用。
下面我们来看下常用的一些线程同步的方式方法。🔻" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://jiuling.me/post/c-%E5%9F%BA%E5%85%83%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9E%84%E9%80%A0/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2021-03-01T21:54:13&#43;08:00" />
<meta property="article:modified_time" content="2021-03-01T21:54:13&#43;08:00" />

<meta itemprop="name" content="C#基元线程同步构造">
<meta itemprop="description" content="我们都知道，程序在运行时，不同线程访问同一个对象，是非常常见的事情。这种情况下如果处理不当，那么就会造成与预期不符的结果，所以线程同步在程序里有着相当重要的作用。
下面我们来看下常用的一些线程同步的方式方法。🔻"><meta itemprop="datePublished" content="2021-03-01T21:54:13&#43;08:00" />
<meta itemprop="dateModified" content="2021-03-01T21:54:13&#43;08:00" />
<meta itemprop="wordCount" content="5861">
<meta itemprop="keywords" content="线程同步,Volatile," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="C#基元线程同步构造"/>
<meta name="twitter:description" content="我们都知道，程序在运行时，不同线程访问同一个对象，是非常常见的事情。这种情况下如果处理不当，那么就会造成与预期不符的结果，所以线程同步在程序里有着相当重要的作用。
下面我们来看下常用的一些线程同步的方式方法。🔻"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">码术</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">主页</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">归档</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">标签</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">分类</li>
      </a><a href="/about">
        <li class="mobile-menu-item">关于</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">码术</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">主页</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">归档</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">标签</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">分类</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/about">关于</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">C#基元线程同步构造</h1>

      <div class="post-meta">
        <span class="post-time"> 2021-03-01 </span>
        <div class="post-category">
            <a href="/categories/.net/"> .NET </a>
            </div>
          <span class="more-meta"> 5861 words </span>
          <span class="more-meta"> 12 mins read </span>
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#用户模式构造">用户模式构造</a>
      <ul>
        <li><a href="#易变构造">易变构造</a></li>
        <li><a href="#互锁构造">互锁构造</a></li>
        <li><a href="#实现简单的自旋锁">实现简单的自旋锁</a></li>
        <li><a href="#interlocked-anything模式"><code>Interlocked Anything</code>模式</a></li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>我们都知道，程序在运行时，不同线程访问同一个对象，是非常常见的事情。这种情况下如果处理不当，那么就会造成与预期不符的结果，所以线程同步在程序里有着相当重要的作用。
下面我们来看下常用的一些线程同步的方式方法。🔻</p>
<p><strong>本文基于<code>.NET4.5</code>框架</strong></p>
<h1 id="用户模式构造">用户模式构造</h1>
<h2 id="易变构造">易变构造</h2>
<p><code>volatile</code>关键字指示一个字段可以由多个同时执行的线程修改，通过<code>volatile</code>关键字，可以保证变量在执行上有着原子性的读、写操作。
<code>volatile</code>关键字可应用于以下类型的字段：</p>
<ul>
<li>引用类型。</li>
<li>指针类型（在不安全的上下文中）。 请注意，虽然指针本身可以是可变的，但是它指向的对象不能是可变的。 换句话说，不能声明“指向可变对象的指针”。</li>
<li>简单类型，如 sbyte、byte、short、ushort、int、uint、char、float 和 bool。</li>
<li>具有以下基本类型之一的 enum 类型：byte、sbyte、short、ushort、int 或 uint。</li>
<li>已知为引用类型的泛型类型参数。</li>
<li>IntPtr 和 UIntPtr。</li>
</ul>
<p>这些描述读起来比较绕口，那么我们通过一个示例来演示以下<code>volatile</code>的基本用法。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#">    <span class="c1">/// &lt;summary&gt;
</span><span class="c1"></span>    <span class="c1">/// 定义测试类
</span><span class="c1"></span>    <span class="c1">/// &lt;/summary&gt;
</span><span class="c1"></span>    <span class="k">public</span> <span class="k">class</span> <span class="nc">VolatileTest</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="kt">bool</span> <span class="n">_isStop</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="k">public</span> <span class="k">void</span> <span class="n">Do</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;任务开始&#34;</span><span class="p">);</span>
            <span class="kt">var</span> <span class="n">th</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="p">(</span><span class="n">Thread1</span><span class="p">);</span>
            <span class="n">th</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>

            <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">5000</span><span class="p">);</span>
            <span class="n">_isStop</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;等待任务完成&#34;</span><span class="p">);</span>
            <span class="n">th</span><span class="p">.</span><span class="n">Join</span><span class="p">();</span>

            <span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">void</span> <span class="n">Thread1</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
            <span class="k">while</span> <span class="p">(!</span><span class="n">_isStop</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">x</span> <span class="p">=</span> <span class="n">x</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&#34;任务执行完成，计数：{x}&#34;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#">        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//调用测试方法
</span><span class="c1"></span>            <span class="k">new</span> <span class="n">VolatileTest</span><span class="p">().</span><span class="n">Do</span><span class="p">();</span>
        <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>先来猜猜上面这段代码的执行结果是怎样的😓😓</p>
<p>代码在编译时，根据不同的编译配置，可能会出现不同的结果。</p>
<ul>
<li>
<p>在<code>Debug</code>模式下，编译器并没有对代码进行优化，所以程序会得到正常的执行结果🔻
<img src="https://i.loli.net/2021/03/01/PvKmZLhQNtl2uM1.jpg" alt="VolatileDebug.jpg"><br>
<em>至于这里的计数为什么会是负数，这个以后有机会在单独写文章分析</em></p>
</li>
<li>
<p>在<code>Release</code>模式下,编译器默认打开了代码优化功能。编译VolatileTest文件时，编译器发现<code>_isStop</code>在<code>Thread1</code>方法中并不会发生改变，并且<strong>对<code>_isStop</code>的检查只会在循环前发生一次，不会每次循环时都检查</strong>。因此会生成一段一直累加x的代码出来。因此，程序运行时，得到了以下结果🔻
<img src="https://i.loli.net/2021/03/01/qkXNTVtiIhaplEu.jpg" alt="VolatileRelease.jpg"></p>
</li>
</ul>
<p>接下来通过<code>IL</code>代码来对比一下两者的不同（左边为<code>Debug</code>版本，右边为<code>Release</code>版本）</p>
<p><img src="https://i.loli.net/2021/03/01/6GfIXBDxwCpRQkM.jpg" alt="VolatileIL.jpg"></p>
<p>在两个版本中，主要有两点不同：</p>
<ol>
<li><code>Debug</code>版本中，在初始化变量时，定义了一个<code>bool</code>类型的变量；<code>Release</code>版本没有</li>
<li><code>Debug</code>版本中，在循环结束前，对定义的<code>bool</code>变量和<code>_isStop</code>进行了计算，然后判断是否需要继续循环；<code>Release</code>版本中直接获取并校验了<code>_isStop</code>的值，结果为<code>false</code>，则无限循环。</li>
</ol>
<p>要解决这个问题其实很简单，就是使用前面所说的<code>Volatile</code>关键字定义变量即可。<code>Volatile</code>能保证变量的原子操作，因此用<code>Volatile</code>定义的变量，编译器是不会进行之前的优化操作。
所以重新修改<code>_isStop</code>变量的定义即可修正前面的问题。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#"><span class="k">private</span> <span class="n">volatile</span> <span class="kt">bool</span> <span class="n">_isStop</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
</code></pre></td></tr></table>
</div>
</div><p>另外，<code>System.Threading.Volatile</code>类还提供了以下两个静态方法来进行变量的读写🔻</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#">            <span class="n">Volatile</span><span class="p">.</span><span class="n">Read</span><span class="p">(</span><span class="k">ref</span> <span class="n">_isStop</span><span class="p">);</span>
            <span class="n">Volatile</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="k">ref</span> <span class="n">_isStop</span><span class="p">,</span><span class="k">true</span><span class="p">);</span>
</code></pre></td></tr></table>
</div>
</div><p>因此通过如下代码也可以修正前面的问题：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#">        <span class="k">public</span> <span class="k">void</span> <span class="n">Thread1</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
            <span class="c1">//这里使用Volatile.Read来读取最新的值
</span><span class="c1"></span>            <span class="k">while</span> <span class="p">(!</span><span class="n">Volatile</span><span class="p">.</span><span class="n">Read</span><span class="p">(</span><span class="k">ref</span> <span class="n">_isStop</span><span class="p">))</span>
            <span class="p">{</span>
                <span class="n">x</span> <span class="p">=</span> <span class="n">x</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&#34;任务执行完成，计数：{x}&#34;</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>如果对上面的概念还是不太理解，那么可以再参考下书中的这样一段定义🔻</p>
<blockquote>
<p>当线程通过共享内存相互通信时，调用<code>Volatile.Write</code>来写入最后一个值，调用<code>Volatile.Read</code>来读取第一个值</p>
</blockquote>
<h2 id="互锁构造">互锁构造</h2>
<p><code>System.Threading.Interlocked</code>类中的每个方法都为多个线程共享的变量提供原子操作。</p>
<blockquote>
<p>调用某个<code>Interlocked</code>方法之前的任何变量写入都在这个<code>Interlocked</code>方法调用之前执行；而这个调用之后的任何变量读取都在这个调用之后读取。</p>
</blockquote>
<p><em><code>volatile</code>只有Read、Write两个方法提供原子性的操作，而<code>Interlocked</code>类中的所有方法都执行一次原子性的读取和写入</em>
该类提供的方法比较多，具体可以参考<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.interlocked?view=netframework-4.5&amp;f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(System.Threading.Interlocked);k(TargetFrameworkMoniker-.NETFramework,Version%253Dv4.5);k(DevLang-csharp)%26rd%3Dtrue">MSDN文档</a></p>
<p>依然很绕口吧🙇‍♂️🙇‍♂️那继续用代码来理解。
该示例使用<code>HttpClient</code>对指定的服务器请求，并显示请求返回的字节数🔻</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#">    <span class="c1">/// &lt;summary&gt;
</span><span class="c1"></span>    <span class="c1">/// 服务器请求状态
</span><span class="c1"></span>    <span class="c1">/// &lt;/summary&gt;
</span><span class="c1"></span>    <span class="k">public</span> <span class="k">enum</span> <span class="n">CoordinationStatus</span>
    <span class="p">{</span>
        <span class="n">AllDone</span><span class="p">,</span>
        <span class="n">Timeout</span><span class="p">,</span>
        <span class="n">Cancel</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span><span class="lnt">88
</span><span class="lnt">89
</span><span class="lnt">90
</span><span class="lnt">91
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#">    <span class="c1">/// &lt;summary&gt;
</span><span class="c1"></span>    <span class="c1">/// 定义测试类
</span><span class="c1"></span>    <span class="c1">/// &lt;/summary&gt;
</span><span class="c1"></span>    <span class="k">public</span> <span class="k">class</span> <span class="nc">InterlockedTest</span>
    <span class="p">{</span>
        <span class="c1">//这个辅助类用于协调所有异步操作
</span><span class="c1"></span>        <span class="k">private</span> <span class="k">readonly</span> <span class="n">AsyncCoordinator</span> <span class="n">_ac</span> <span class="p">=</span> <span class="k">new</span> <span class="n">AsyncCoordinator</span><span class="p">();</span>

        <span class="c1">//这是想要查询的web服务器及其响应（异常或int）的集合
</span><span class="c1"></span>        <span class="c1">//注意：多个线程访问该字典不需要以同步方式进行
</span><span class="c1"></span>        <span class="c1">//因为构造后键就是只读的
</span><span class="c1"></span>        <span class="k">private</span> <span class="k">readonly</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">String</span><span class="p">,</span> <span class="n">Object</span><span class="p">&gt;</span> <span class="n">_remoteServers</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Dictionary</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span> <span class="kt">object</span><span class="p">&gt;</span> <span class="p">{</span>
        <span class="p">{</span><span class="s">&#34;https://www.microsoft.com&#34;</span> <span class="p">,</span><span class="k">null</span><span class="p">},</span>
        <span class="p">{</span><span class="s">&#34;https://www.bing.com&#34;</span><span class="p">,</span><span class="k">null</span><span class="p">},</span>
        <span class="p">{</span><span class="s">&#34;https://www.google.com&#34;</span><span class="p">,</span><span class="k">null</span><span class="p">}</span>
        <span class="p">};</span>
        <span class="k">public</span> <span class="k">void</span> <span class="n">Do</span><span class="p">(</span><span class="kt">int</span> <span class="n">timeout</span> <span class="p">=</span> <span class="n">Timeout</span><span class="p">.</span><span class="n">Infinite</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">httpClient</span> <span class="p">=</span> <span class="k">new</span> <span class="n">HttpClient</span><span class="p">();</span>
            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">server</span> <span class="k">in</span> <span class="n">_remoteServers</span><span class="p">.</span><span class="n">Keys</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">_ac</span><span class="p">.</span><span class="n">AboutToBegin</span><span class="p">(</span><span class="m">1</span><span class="p">);</span><span class="c1">//这里也可以修改为下面注释中的方式
</span><span class="c1"></span>                <span class="n">httpClient</span><span class="p">.</span><span class="n">GetByteArrayAsync</span><span class="p">(</span><span class="n">server</span><span class="p">).</span><span class="n">ContinueWith</span><span class="p">(</span><span class="n">task</span> <span class="p">=&gt;</span> <span class="n">ComputeResult</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">task</span><span class="p">));</span>
            <span class="p">}</span>

            <span class="c1">// //一次性向AboutToBegin方法传递所有的请求数量
</span><span class="c1"></span>            <span class="c1">// _ac.AboutToBegin(_remoteServers.Count);
</span><span class="c1"></span>            <span class="c1">// foreach (var server in _remoteServers.Keys)
</span><span class="c1"></span>            <span class="c1">// {
</span><span class="c1"></span>            <span class="c1">//     httpClient.GetByteArrayAsync(server).ContinueWith(task =&gt; ComputeResult(server, task));
</span><span class="c1"></span>            <span class="c1">// }
</span><span class="c1"></span>
            <span class="c1">//告诉AsyncCoordinator所有操作都已发起，并在所有操作完成
</span><span class="c1"></span>            <span class="c1">//调用Cancel或者发生超时的时候调用AllDone
</span><span class="c1"></span>            <span class="n">_ac</span><span class="p">.</span><span class="n">AllBegun</span><span class="p">(</span><span class="n">AllDone</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">private</span> <span class="k">void</span> <span class="n">ComputeResult</span><span class="p">(</span><span class="kt">string</span> <span class="n">server</span><span class="p">,</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">Byte</span><span class="p">[]&gt;</span> <span class="n">task</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">object</span> <span class="n">result</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">task</span><span class="p">.</span><span class="n">Exception</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">result</span> <span class="p">=</span> <span class="n">task</span><span class="p">.</span><span class="n">Exception</span><span class="p">.</span><span class="n">InnerException</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="c1">//线程池线程处理I/O完成
</span><span class="c1"></span>                <span class="c1">//在此添加自己的计算密集型算法
</span><span class="c1"></span>                <span class="c1">//本例只是返回长度
</span><span class="c1"></span>                <span class="n">result</span> <span class="p">=</span> <span class="n">task</span><span class="p">.</span><span class="n">Result</span><span class="p">.</span><span class="n">Length</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="c1">//保存结果(exception/sum)，指出1个操作完成
</span><span class="c1"></span>            <span class="n">_remoteServers</span><span class="p">[</span><span class="n">server</span><span class="p">]</span> <span class="p">=</span> <span class="n">result</span><span class="p">;</span>
            <span class="n">_ac</span><span class="p">.</span><span class="n">JustEnded</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="c1">//调用这个方法指出结果已无关紧要
</span><span class="c1"></span>        <span class="k">public</span> <span class="k">void</span> <span class="n">Cancel</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">_ac</span><span class="p">.</span><span class="n">Cancel</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="c1">//所有Web服务器都响应、调用了Cancel或者发生超时，就调用该方法
</span><span class="c1"></span>        <span class="k">private</span> <span class="k">void</span> <span class="n">AllDone</span><span class="p">(</span><span class="n">CoordinationStatus</span> <span class="n">status</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">switch</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">case</span> <span class="n">CoordinationStatus</span><span class="p">.</span><span class="n">Cancel</span><span class="p">:</span>
                    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;请求取消&#34;</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="n">CoordinationStatus</span><span class="p">.</span><span class="n">Timeout</span><span class="p">:</span>
                    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;请求超时&#34;</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="n">CoordinationStatus</span><span class="p">.</span><span class="n">AllDone</span><span class="p">:</span>
                    <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">&#34;请求完成，结果：&#34;</span><span class="p">);</span>
                    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">server</span> <span class="k">in</span> <span class="n">_remoteServers</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&#34;{server.Key}&#34;</span><span class="p">);</span>
                        <span class="kt">object</span> <span class="n">result</span> <span class="p">=</span> <span class="n">server</span><span class="p">.</span><span class="n">Value</span><span class="p">;</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="k">is</span> <span class="n">Exception</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&#34;请求发生异常：{result.GetType().Name}&#34;</span><span class="p">);</span>
                        <span class="p">}</span>
                        <span class="k">else</span>
                        <span class="p">{</span>
                            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&#34;返回字节数：{result}&#34;</span><span class="p">);</span>
                        <span class="p">}</span>
                    <span class="p">}</span>
                    <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#">    <span class="c1">/// &lt;summary&gt;
</span><span class="c1"></span>    <span class="c1">/// 这个辅助类用于协调所有异步操作
</span><span class="c1"></span>    <span class="c1">/// &lt;/summary&gt;
</span><span class="c1"></span>    <span class="k">public</span> <span class="k">class</span> <span class="nc">AsyncCoordinator</span>
    <span class="p">{</span>
        <span class="c1">//AllBegun内部调用JustEnded来递减它
</span><span class="c1"></span>        <span class="k">private</span> <span class="kt">int</span> <span class="n">_opCount</span> <span class="p">=</span> <span class="m">1</span><span class="p">;</span>
        <span class="c1">//0 = false  1= true
</span><span class="c1"></span>        <span class="k">private</span> <span class="kt">int</span> <span class="n">_statusReported</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">private</span> <span class="n">Action</span><span class="p">&lt;</span><span class="n">CoordinationStatus</span><span class="p">&gt;</span> <span class="n">_callback</span><span class="p">;</span>
        <span class="k">private</span> <span class="n">Timer</span> <span class="n">_timer</span><span class="p">;</span>

        <span class="c1">//该方法必须在发起一个操作之前调用
</span><span class="c1"></span>        <span class="k">public</span> <span class="k">void</span> <span class="n">AboutToBegin</span><span class="p">(</span><span class="kt">int</span> <span class="n">opsToAdd</span> <span class="p">=</span> <span class="m">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Interlocked</span><span class="p">.</span><span class="n">Add</span><span class="p">(</span><span class="k">ref</span> <span class="n">_opCount</span><span class="p">,</span> <span class="n">opsToAdd</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="c1">//该方法必须在处理好一个操作的结果之后调用
</span><span class="c1"></span>        <span class="k">public</span> <span class="k">void</span> <span class="n">JustEnded</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Interlocked</span><span class="p">.</span><span class="n">Decrement</span><span class="p">(</span><span class="k">ref</span> <span class="n">_opCount</span><span class="p">)</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">ReportStatus</span><span class="p">(</span><span class="n">CoordinationStatus</span><span class="p">.</span><span class="n">AllDone</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">//该方法必须在发起所有操作之后调用
</span><span class="c1"></span>        <span class="k">public</span> <span class="k">void</span> <span class="n">AllBegun</span><span class="p">(</span><span class="n">Action</span><span class="p">&lt;</span><span class="n">CoordinationStatus</span><span class="p">&gt;</span> <span class="n">callback</span><span class="p">,</span> <span class="kt">int</span> <span class="n">timeout</span> <span class="p">=</span> <span class="n">Timeout</span><span class="p">.</span><span class="n">Infinite</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_callback</span> <span class="p">=</span> <span class="n">callback</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="p">!=</span> <span class="n">Timeout</span><span class="p">.</span><span class="n">Infinite</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">_timer</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Timer</span><span class="p">(</span><span class="n">TimeExpired</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="n">timeout</span><span class="p">,</span> <span class="n">Timeout</span><span class="p">.</span><span class="n">Infinite</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">JustEnded</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">void</span> <span class="n">TimeExpired</span><span class="p">(</span><span class="kt">object</span> <span class="n">o</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">ReportStatus</span><span class="p">(</span><span class="n">CoordinationStatus</span><span class="p">.</span><span class="n">Timeout</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">void</span> <span class="n">Cancel</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">ReportStatus</span><span class="p">(</span><span class="n">CoordinationStatus</span><span class="p">.</span><span class="n">Cancel</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">void</span> <span class="n">ReportStatus</span><span class="p">(</span><span class="n">CoordinationStatus</span> <span class="n">status</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//如果状态从未报告过，就报告它；否则忽略它
</span><span class="c1"></span>            <span class="k">if</span> <span class="p">(</span><span class="n">Interlocked</span><span class="p">.</span><span class="n">Exchange</span><span class="p">(</span><span class="k">ref</span> <span class="n">_statusReported</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">_callback</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#">        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//调用测试方法
</span><span class="c1"></span>            <span class="k">new</span> <span class="n">InterlockedTest</span><span class="p">().</span><span class="n">Do</span><span class="p">();</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="c1">//↓↓↓代码运行结果如下↓↓↓
</span><span class="c1"></span>
        <span class="c1">// 请求完成，结果：
</span><span class="c1"></span>        <span class="c1">// https://www.microsoft.com
</span><span class="c1"></span>        <span class="c1">// 返回字节数：185796
</span><span class="c1"></span>        <span class="c1">// https://www.bing.com
</span><span class="c1"></span>        <span class="c1">// 返回字节数：114613
</span><span class="c1"></span>        <span class="c1">// https://www.google.com
</span><span class="c1"></span>        <span class="c1">// 请求发生异常：HttpRequestException
</span></code></pre></td></tr></table>
</div>
</div><p>接下来说明一下这个示例🔻
1.<code>InterlockedTest</code>类主要负责定义一个多线程访问网站的字典，并且对字典中的网站进行访问。任务开始前会向<code>AsyncCoordinator</code>类发送本次需要请求的操作数量，所有任务创建完成后调用<code>AllBegun</code>方法向辅助类报告任务已创建完成，并且绑定一个回调方法<code>AllDone</code>（该方法的作用是打印所有请求的结果）。
2.<code>AsyncCoordinator</code>类用于协调所有异步操作，之所以单独提取出来，是因为这个类的功能可以复用。该类的两个公共方法<code>AboutToBegin</code>和<code>JustEnded</code>分别用于对内部维护的异步任务数（<code>_opCount</code>）进行原子的加、减操作（通过<code>Interlocked.Add</code>、<code>Interlocked.Decrement</code>来实现）。当任务数为0时，调用<code>ReportStatus</code>方法向<code>InterlockedTest</code>报告执行结果，说明所有异步任务已完成。</p>
<p>这里特别说明以下几个点🔻</p>
<ul>
<li><code>_opCount</code>变量的初始值为1（而非0），这一点很重要。假定初始值为0，当某一个请求到完成又很迅速时（下一个任务还没调用<code>AboutToBegin</code>的时候当前任务就已经完成并且调用了<code>JustEnded</code>方法），那么这时就会导致<code>AllDone</code>被提前执行。因此初始化时将<code>_opCount</code>的值设置为1，等所有任务添加完成后，调用<code>AllBegun</code>方法时再通过<code>JustEnded</code>将那个1减掉。</li>
<li><code>_statusReported</code>变量实际上是作为一个<code>Boolean</code>来使用的，因为<code>Interlocked</code>类不提供<code>Boolean</code>类型的原子操作，所以这里我们使用<code>int</code>类型的变量来代替。</li>
<li>示例中的<code>Cancel</code>方法没有做展示，想要看效果的同学可以修改代码自己调用。</li>
<li>示例中的<code>Timeout</code>方法没有做展示，因为默认传递的参数是不超时，想要看效果的同学可以修改代码自己调用。</li>
</ul>
<h2 id="实现简单的自旋锁">实现简单的自旋锁</h2>
<p>前面所说的<code>Interlocked</code>的方法很好用，但是主要用于操作<code>Int32</code>类型，如果需要原子性的操作类中的一组字段，<code>Interlocked</code>很明显是做不到的。所以这时我们可以构造一个让线程自旋模块，来实现代码同步。<br>
所谓<strong>自旋锁（spin lock）</strong>，其实就是在多线程的处理中，一个线程暂时“原地打转”，以免跑去跟另外一个线程竞争资源。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#">    <span class="c1">/// &lt;summary&gt;
</span><span class="c1"></span>    <span class="c1">/// 定义一个简单的自旋锁
</span><span class="c1"></span>    <span class="c1">/// &lt;/summary&gt;
</span><span class="c1"></span>    <span class="k">public</span> <span class="k">class</span> <span class="nc">SpinLockTest</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="kt">int</span> <span class="n">_isInUse</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

        <span class="k">public</span> <span class="k">void</span> <span class="n">Enter</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">while</span> <span class="p">(</span><span class="k">true</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">Interlocked</span><span class="p">.</span><span class="n">Exchange</span><span class="p">(</span><span class="k">ref</span> <span class="n">_isInUse</span><span class="p">,</span> <span class="m">1</span><span class="p">)</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">return</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="c1">//如果有线程正在调用，那么后来的线程就一直在这里“自旋”
</span><span class="c1"></span>            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">void</span> <span class="n">Leave</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">Interlocked</span><span class="p">.</span><span class="n">Exchange</span><span class="p">(</span><span class="k">ref</span> <span class="n">_isInUse</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#">    <span class="c1">/// &lt;summary&gt;
</span><span class="c1"></span>    <span class="c1">/// 使用自旋锁
</span><span class="c1"></span>    <span class="c1">/// &lt;/summary&gt;
</span><span class="c1"></span>    <span class="k">public</span> <span class="k">class</span> <span class="nc">MySpinLock</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="kt">int</span> <span class="n">_count</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="n">SpinLockTest</span> <span class="n">_spinLockTest</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SpinLockTest</span><span class="p">();</span>
        <span class="k">public</span> <span class="k">void</span> <span class="n">Do</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">Task</span><span class="p">.</span><span class="n">Run</span><span class="p">(()</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="c1">//定义100个线程，同时对_count++
</span><span class="c1"></span>                <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
                <span class="p">{</span>
                    <span class="kt">var</span> <span class="n">th</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span>
                    <span class="p">{</span>
                        <span class="n">_spinLockTest</span><span class="p">.</span><span class="n">Enter</span><span class="p">();</span>
                        <span class="c1">//一次只有一个线程能访问当前代码块
</span><span class="c1"></span>                        <span class="n">_count</span><span class="p">++;</span>                        
                        <span class="n">_spinLockTest</span><span class="p">.</span><span class="n">Leave</span><span class="p">();</span>
                    <span class="p">});</span>
                    <span class="n">th</span><span class="p">.</span><span class="n">Start</span><span class="p">();</span>
                <span class="p">}</span>
            <span class="p">});</span>
            <span class="c1">//等待所有线程调用完成
</span><span class="c1"></span>            <span class="n">Thread</span><span class="p">.</span><span class="n">Sleep</span><span class="p">(</span><span class="m">10</span> <span class="p">*</span> <span class="m">1000</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&#34;_count={_count}&#34;</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>这个自旋锁实际上很简单<br>
当两个线程同时调用<code>SpinLockTest.Enter()</code>时，那么<code>Interlocked.Exchange(ref _isInUse, 1)</code>会确保一个线程将<code>_isInUse</code>由0变成1，并发现其初始值为0，所以跳出循环并继续执行后续逻辑；另一个线程将<code>_isInUse</code>由1变成1，初始值为1，所以会一直进行“自旋”，等待直到<code>_isInUse</code>的值再次变为0。<br>
当第一个线程执行完需要同步的代码块后调用<code>_spinLockTest.Leave()</code>方法，将<code>_isInUse</code>的值再次变为0，此时“自旋”的线程进入要同步的代码块。</p>
<p>“自旋锁”虽然简单，但是也有以下的缺点：</p>
<ul>
<li>因为一直“自旋”，所以会浪费大量的CPU时间，因此该方法<strong>仅适用于执行的非常快的代码块</strong>。</li>
<li>如果<strong>占用锁</strong>的线程优先级低于<strong>想要获取锁</strong>的线程，那么这里会出现活锁的情况（因为占用锁的线程根本没有机会执行）<em>这部分为线程优先级的知识，这里不过多的解释</em>。</li>
</ul>
<h2 id="interlocked-anything模式"><code>Interlocked Anything</code>模式</h2>
<p>我们在使用<code>Interlocked</code>方法的时候，会发现它有好多常用的操作都不支持，比如<code>Min</code>、<code>Max</code>、<code>And</code>、<code>Or</code>、<code>Xor</code>等，但是<code>Interlocked</code>提供了一个方法<code>Interlocked.CompareExchange</code>，可以进行两个数的比较。我们所说的 <strong><code>Interlocked Anything</code>模式</strong> 就是运用了该方法扩展出来的一种写法。</p>
<p><strong><code>Interlocked Anything</code>模式</strong>有点类似数据库的乐观并发模式，下面我们使用该模式来实现一个原子的<code>Max</code>方法。</p>
<blockquote>
<p>乐观锁的特点：在提交数据更新之前，每个事务会先检查在该事务读取数据之后，有没有其他事务又修改了该数据。如果其他事务更新了该数据，正在提交的事务将会进行回滚。</p>
</blockquote>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#">        <span class="c1">/// &lt;summary&gt;
</span><span class="c1"></span>        <span class="c1">/// 获取两个数的最大值
</span><span class="c1"></span>        <span class="c1">/// &lt;/summary&gt;
</span><span class="c1"></span>        <span class="k">public</span> <span class="k">static</span> <span class="kt">int</span> <span class="n">Max</span><span class="p">(</span><span class="k">ref</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="kt">int</span> <span class="k">value</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">currentVal</span> <span class="p">=</span> <span class="n">target</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">startVal</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">desiredVal</span><span class="p">;</span>
            <span class="k">do</span>
            <span class="p">{</span>
                <span class="c1">//记录本次循环开始的起始值
</span><span class="c1"></span>                <span class="n">startVal</span> <span class="p">=</span> <span class="n">currentVal</span><span class="p">;</span>

                <span class="c1">//可以用startVal执行你希望的任何操作，本例以获取最大值为例
</span><span class="c1"></span>                <span class="n">desiredVal</span> <span class="p">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">Max</span><span class="p">(</span><span class="n">startVal</span><span class="p">,</span> <span class="k">value</span><span class="p">);</span>

                <span class="c1">//返回target的原始值（修改前的值，因为执行代码期间该值可能会被其他线程修改）
</span><span class="c1"></span>                <span class="n">currentVal</span> <span class="p">=</span> <span class="n">Interlocked</span><span class="p">.</span><span class="n">CompareExchange</span><span class="p">(</span><span class="k">ref</span> <span class="n">target</span><span class="p">,</span> <span class="n">desiredVal</span><span class="p">,</span> <span class="n">startVal</span><span class="p">);</span>

                <span class="c1">//如果target的值被修改，那么currentVal的值就不会等于startVal值
</span><span class="c1"></span>                <span class="c1">//重新循环一次用最新值进行计算
</span><span class="c1"></span>            <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">startVal</span> <span class="p">!=</span> <span class="n">currentVal</span><span class="p">);</span>

            <span class="k">return</span> <span class="n">desiredVal</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>结合前面所说的乐观锁的特点，现在来分析以下这段代码。</p>
<ol>
<li>进入方法后<code>currentVal</code>值被初始化为<code>target</code>的值</li>
<li>循环开始后，初始化本次操作的起始值<code>startVal</code></li>
<li>执行需要的代码操作（本例以获取两个数的最大值为例）</li>
<li>操作完成后，调用<code>Interlocked.CompareExchange</code>方法比较<code>target</code>和<code>startVal</code>是否相等。如果相等，则将<code>desiredVal</code>赋值给<code>target</code>（也就是上一步的操作结果）；如果不相等，则说明在方法执行期间，<code>target</code>发生了改变，这时将最新的值赋值给<code>currentVal</code></li>
<li>如果上一步的<code>target</code>和<code>startVal</code>相等，那么<code>Interlocked.CompareExchange</code>方法的返回值<code>currentVal</code>，也将和前面两个值相等，此时跳出循环，方法执行完成。如果<code>target</code>和<code>startVal</code>不相等，则用最新的<code>target</code>值（即<code>currentVal</code>）重新进行循环。</li>
</ol>
<p>《CLR via C#》的作者在书中写道，自己在大量的代码中都运用了这个模式，还专门写了一个泛型的<code>Morph</code>来封装了这个模式。如下🔻</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#">        <span class="k">public</span> <span class="k">delegate</span> <span class="kt">int</span> <span class="n">Morpher</span><span class="p">&lt;</span><span class="n">TResult</span><span class="p">,</span> <span class="n">TArgument</span><span class="p">&gt;(</span><span class="kt">int</span> <span class="n">startValue</span><span class="p">,</span> <span class="n">TArgument</span> <span class="n">argument</span><span class="p">,</span> <span class="k">out</span> <span class="n">TResult</span> <span class="n">morphResult</span><span class="p">);</span>
        <span class="k">public</span> <span class="k">static</span> <span class="n">TResult</span> <span class="n">Morph</span><span class="p">&lt;</span><span class="n">TResult</span><span class="p">,</span> <span class="n">TArgument</span><span class="p">&gt;(</span><span class="k">ref</span> <span class="kt">int</span> <span class="n">target</span><span class="p">,</span> <span class="n">TArgument</span> <span class="n">argument</span><span class="p">,</span> <span class="n">Morpher</span><span class="p">&lt;</span><span class="n">TResult</span><span class="p">,</span> <span class="n">TArgument</span><span class="p">&gt;</span> <span class="n">morpher</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">TResult</span> <span class="n">morphResult</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">currentVal</span> <span class="p">=</span> <span class="n">target</span><span class="p">,</span> <span class="n">startVal</span><span class="p">,</span> <span class="n">desiredVal</span><span class="p">;</span>
            <span class="k">do</span>
            <span class="p">{</span>
                <span class="n">startVal</span> <span class="p">=</span> <span class="n">currentVal</span><span class="p">;</span>
                <span class="n">desiredVal</span> <span class="p">=</span> <span class="n">morpher</span><span class="p">(</span><span class="n">startVal</span><span class="p">,</span> <span class="n">argument</span><span class="p">,</span> <span class="k">out</span> <span class="n">morphResult</span><span class="p">);</span>
                <span class="n">currentVal</span> <span class="p">=</span> <span class="n">Interlocked</span><span class="p">.</span><span class="n">CompareExchange</span><span class="p">(</span><span class="k">ref</span> <span class="n">target</span><span class="p">,</span> <span class="n">desiredVal</span><span class="p">,</span> <span class="n">startVal</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">startVal</span> <span class="p">!=</span> <span class="n">currentVal</span><span class="p">);</span>

            <span class="k">return</span> <span class="n">morphResult</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre class="chroma"><code class="language-C#" data-lang="C#">        <span class="k">static</span> <span class="k">void</span> <span class="n">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//调用测试方法，同样已Max为例
</span><span class="c1"></span>            <span class="kt">int</span> <span class="n">a</span> <span class="p">=</span> <span class="m">2</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">b</span> <span class="p">=</span> <span class="m">3</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">a1</span> <span class="p">=</span> <span class="n">a</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">c</span> <span class="p">=</span> <span class="n">InterlockedAnythingTest</span><span class="p">.</span><span class="n">Morph</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;(</span><span class="k">ref</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="k">out</span> <span class="kt">int</span> <span class="n">z</span><span class="p">)</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="n">z</span> <span class="p">=</span> <span class="m">999</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">Math</span><span class="p">.</span><span class="n">Max</span><span class="p">(</span><span class="n">a1</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span> <span class="p">;</span>
            <span class="p">});</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="p">(</span><span class="s">$&#34;max value={a},return value={c}&#34;</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="n">ReadLine</span><span class="p">();</span>
        <span class="p">}</span>

            <span class="c1">//↓↓↓代码运行结果如下↓↓↓            
</span><span class="c1"></span>
            <span class="c1">//max value=3,return value=999
</span></code></pre></td></tr></table>
</div>
</div><p>参考资料：<br>
《CLR via C#》<br>
<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/volatile?f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(volatile_CSharpKeyword);k(TargetFrameworkMoniker-.NETFramework,Version%253Dv4.5);k(DevLang-csharp)%26rd%3Dtrue">volatile（C# 参考）（MSDN）</a><br>
<a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.threading.interlocked?view=netframework-4.5&amp;f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(System.Threading.Interlocked);k(TargetFrameworkMoniker-.NETFramework,Version%253Dv4.5);k(DevLang-csharp)%26rd%3Dtrue">Interlocked 类（MSDN）</a></p>
<p><em><strong>本文未完，后面还会持续更新，学一点总结一点</strong></em>🐶🐶</p>
    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">九零</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2021-03-01
        
    </span>
  </p>
  
  <p class="copyright-item">
    <span class="item-title">License</span>
    <span class="item-content"><a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank">CC BY-NC-ND 4.0</a></span>
  </p>
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/">线程同步</a>
          <a href="/tags/volatile/">Volatile</a>
          </div>
      <nav class="post-nav">
        
        <a class="next" href="/post/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/">
            <span class="next-text nav-default">设计模式-代理模式</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
</div>

<div class="copyright">
  

  <span class="copyright-year">
    &copy; 
    2021<span class="heart"><i class="iconfont icon-heart"></i></span><span>九零</span>
    <span>| Powered by<a class="hexo-link" href="https://gohugo.io"> Hugo</a></span>
    <span>| Theme -<a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even"> Even</a></span>    
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js" integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin="anonymous"></script>



<script type="text/javascript" src="/js/main.min.c99b103c33d1539acf3025e1913697534542c4a5aa5af0ccc20475ed2863603b.js"></script>








</body>
</html>
