<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>.NET托管堆和垃圾回收</title>
    <url>/2021/02/05/NET%E6%89%98%E7%AE%A1%E5%A0%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h1>托管堆基础</h1>
<h2 id="分配资源"><a class="header-anchor" href="#分配资源">¶</a>分配资源</h2>
<p>C#要求所有对象都从<strong>托管堆</strong>分配。进程初始化时，CLR划出一个地址空间区域作为托管堆。CLR还会维护一个叫<strong>NextObjPtr</strong>的指针，该指针指向下一个对象在堆中的位置。</p>
<p>一个区域被非垃圾填满后，CLR会分配更多的区域出来，一直重复，直到进程地址空间被填满。(32位进程最多能分配1.5GB;64位进程最多能分配8TB)</p>
<a id="more"></a>
<p>c#的new关键字实际上执行了以下步骤：</p>
<ol>
<li>计算类型的字段所需的字节数。</li>
<li>加上对象开销所需的字节数(每个对象有两个开销字段：<strong>类型对象指针</strong>和<strong>同步块索引</strong>)。</li>
<li>CLR检查区域中是否有足够分配对象所需的字节数。如果有足够的空间，就在<strong>NextObjPtr</strong>处放入该对象，并且将<strong>NextObjPtr</strong>返回给类型的构造器(<strong>this</strong>)。<strong>NextObjPtr</strong>会在自身的基础上加上对象占用的字节数来得到一个新值，即下一个对象的地址。</li>
</ol>
<p><img src="https://i.loli.net/2021/02/01/uGlTUWacveLp7bx.png" alt="初始化托管堆"></p>
<h2 id="垃圾回收算法"><a class="header-anchor" href="#垃圾回收算法">¶</a>垃圾回收算法</h2>
<p>CLR的垃圾回收机制采用的是<strong>引用跟踪算法</strong>，该算法只关心引用类型的变量，因为只有这种变量才能引用堆上的对象。我们将所有这些引用类型的变量称为<strong>根</strong>。</p>
<p>垃圾回收的机制有以下步骤：</p>
<ol>
<li>垃圾回收开始时，CLR首先暂停所有线程(防止检查期间对象状态改变)。</li>
<li>进入标记阶段，CLR遍历堆上的所有对象，并将同步块索引中的某一位设置为0(标记为0时表示对象需要被删除)。</li>
<li>CLR检查所有<strong>根</strong>，如果这个根引用了堆上的对象，那么CLR会标记这个对象，将同步块索引的值修改为1。如果一个对象被标记，CLR还会检查那个对象中的根，标记他们引用的对象。<br>
如下图，B对象含有一个E对象的引用，标记B对象的同时也会标记E对象。</li>
</ol>
<p><img src="https://i.loli.net/2021/02/01/RLEY5iZUDfWQn9c.png" alt="垃圾回收前的堆状态"></p>
<ol start="4">
<li>检查完成后，堆中的对象分为已标记和未标记两种状态。</li>
</ol>
<ul>
<li>已标记的对象不能被垃圾回收，因为有根的引用，我们成为<strong>可达</strong>。</li>
<li>未标记的对象将被回收，因为已经没有根的引用，我们成为<strong>不可达</strong>。</li>
</ul>
<ol start="5">
<li>CLR进入(压缩)阶段，首先将<strong>可达</strong>的部分连续排列。在压缩过程中，因为会移动对象在内存中的位置，所以CLR还需要重新为每个对象计算新的指针位置。压缩完成后，<strong>NextObjPtr</strong>将指向最后一个<strong>可达</strong>对象的位置。</li>
</ol>
<p><img src="https://i.loli.net/2021/02/01/bQlMRgHjqxfsO9C.png" alt="压缩后的堆状态"></p>
<p>这部分只是简单介绍下托管堆的初始化和垃圾回收的基本算法。<br>
后面会继续开文章或者补充具体每一代是如何进行垃圾回收的。</p>
]]></content>
      <categories>
        <category>.NET</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
</search>
