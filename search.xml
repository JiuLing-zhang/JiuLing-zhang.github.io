<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C#托管堆和垃圾回收</title>
    <url>/2021/02/05/C-%E6%89%98%E7%AE%A1%E5%A0%86%E5%92%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<h2 id="托管堆基础"><a class="header-anchor" href="#托管堆基础">¶</a>托管堆基础</h2>
<h3 id="分配资源"><a class="header-anchor" href="#分配资源">¶</a>分配资源</h3>
<p>C#要求所有对象都从<strong>托管堆</strong>分配。进程初始化时，CLR划出一个地址空间区域作为托管堆。CLR还会维护一个叫<strong>NextObjPtr</strong>的指针，该指针指向下一个对象在堆中的位置。</p>
<p>一个区域被非垃圾填满后，CLR会分配更多的区域出来，一直重复，直到进程地址空间被填满。(32位进程最多能分配1.5GB;64位进程最多能分配8TB)</p>
<a id="more"></a>
<p>c#的new关键字实际上执行了以下步骤：</p>
<ol>
<li>计算类型的字段所需的字节数。</li>
<li>加上对象开销所需的字节数(每个对象有两个开销字段：<strong>类型对象指针</strong>和<strong>同步块索引</strong>)。</li>
<li>CLR检查区域中是否有足够分配对象所需的字节数。如果有足够的空间，就在<strong>NextObjPtr</strong>处放入该对象，并且将<strong>NextObjPtr</strong>返回给类型的构造器(<strong>this</strong>)。<strong>NextObjPtr</strong>会在自身的基础上加上对象占用的字节数来得到一个新值，即下一个对象的地址。</li>
</ol>
<p><img src="https://i.loli.net/2021/02/01/uGlTUWacveLp7bx.png" alt="初始化托管堆"></p>
<h3 id="垃圾回收算法"><a class="header-anchor" href="#垃圾回收算法">¶</a>垃圾回收算法</h3>
<p>CLR的垃圾回收机制采用的是<strong>引用跟踪算法</strong>，该算法只关心引用类型的变量，因为只有这种变量才能引用堆上的对象。我们将所有这些引用类型的变量称为<strong>根</strong>。</p>
<p>垃圾回收的机制有以下步骤：</p>
<ol>
<li>垃圾回收开始时，CLR首先暂停所有线程(防止检查期间对象状态改变)。</li>
<li>进入标记阶段，CLR遍历堆上的所有对象，并将同步块索引中的某一位设置为0(标记为0时表示对象需要被删除)。</li>
<li>CLR检查所有<strong>根</strong>，如果这个根引用了堆上的对象，那么CLR会标记这个对象，将同步块索引的值修改为1。如果一个对象被标记，CLR还会检查那个对象中的根，标记他们引用的对象。<br>
如下图，B对象含有一个E对象的引用，标记B对象的同时也会标记E对象。</li>
</ol>
<p><img src="https://i.loli.net/2021/02/01/RLEY5iZUDfWQn9c.png" alt="垃圾回收前的堆状态"></p>
<ol start="4">
<li>检查完成后，堆中的对象分为已标记和未标记两种状态。</li>
</ol>
<ul>
<li>已标记的对象不能被垃圾回收，因为有根的引用，我们成为<strong>可达</strong>。</li>
<li>未标记的对象将被回收，因为已经没有根的引用，我们成为<strong>不可达</strong>。</li>
</ul>
<ol start="5">
<li>CLR进入(压缩)阶段，首先将<strong>可达</strong>的部分连续排列。在压缩过程中，因为会移动对象在内存中的位置，所以CLR还需要重新为每个对象计算新的指针位置。压缩完成后，<strong>NextObjPtr</strong>将指向最后一个<strong>可达</strong>对象的位置。</li>
</ol>
<p><img src="https://i.loli.net/2021/02/01/bQlMRgHjqxfsO9C.png" alt="压缩后的堆状态"></p>
<p>这部分只是简单介绍下托管堆的初始化和垃圾回收的基本算法。<br>
后面会继续开文章或者补充具体每一代是如何进行垃圾回收的。</p>
]]></content>
      <categories>
        <category>.NET</category>
      </categories>
      <tags>
        <tag>.NET</tag>
        <tag>C#</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title>C#使用decimal.TryParse转换时，字符串中有逗号的坑</title>
    <url>/2021/02/06/C-%E4%BD%BF%E7%94%A8decimal-TryParse%E8%BD%AC%E6%8D%A2%E6%97%B6%EF%BC%8C%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%9C%89%E9%80%97%E5%8F%B7%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<h2 id="起源"><a class="header-anchor" href="#起源">¶</a>起源</h2>
<p>一切都要从那个线上bug说起，执行 decimal.TryParse 时程序并没有按照预期输出结果💔💔💔</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> input = <span class="string">&quot;1,2,3&quot;</span>;</span><br><span class="line"><span class="built_in">decimal</span> output;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">decimal</span>.TryParse(input, <span class="keyword">out</span> output))</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;<span class="subst">&#123;output&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;Unable to decimal <span class="subst">&#123;input&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里意外的输出了 123</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>因为按照我的理解这里是不能成功转换的，所以排查问题的着重点根本就没放在这，以至于整个排查过程也显得颇为辛苦。</p>
<h2 id="查看究竟"><a class="header-anchor" href="#查看究竟">¶</a>查看究竟</h2>
<p>去MSDN上翻帮助文档，发现TryParse有这样一个重载方法<br>
<img src="https://i.loli.net/2021/02/06/Hwfr16SxCT38yJm.png" alt="TryParse示例1.png"></p>
<p>看到Globalization的时候就知道凉了一半，在往下看示例，果然，<strong>货币符号</strong> 、<strong>千分位</strong> 、<strong>小数点</strong> 全出来了。<br>
<img src="https://i.loli.net/2021/02/06/JTMPyn4KHRS7a3X.png" alt="TryParse示例2.png"></p>
<p>现在问题很明显了，我的代码没有转换失败很有可能就是因为<strong>逗号被识别成了千分位</strong>。<br>
反编译一下，发现转换的时候确实使用了一个默认值 System.Globalization.NumberStyles.Number。<br>
<img src="https://i.loli.net/2021/02/06/yYKFJgzOPRL5BpA.png" alt="TryParse示例3.png"></p>
<p>继续来看这个枚举值，微软官方文档里给的说明如下：</p>
<blockquote>
<p>指示使用 AllowLeadingWhite、AllowTrailingWhite、AllowLeadingSign、AllowTrailingSign、AllowDecimalPoint 和 AllowThousands 样式。 这是复合数字样式。<br>
<img src="https://i.loli.net/2021/02/06/TdZWN3b5fV7vDnh.png" alt="TryParse示例4.png"></p>
</blockquote>
<p>我们从最后一个类型 <strong>AllowThousands</strong> 可以看出来，默认确实使用了千分位，所以在上述示例中&quot;1,2,3&quot;的确能够成功的完成转换。</p>
<h2 id="问题延申"><a class="header-anchor" href="#问题延申">¶</a>问题延申</h2>
<p>默认使用了千分位解析没错，但是&quot;1,2,3&quot;这个字符串的逗号也没在实际的千分位位置，这又是咋回事呢，想不通。😨😨😨</p>
<p>继续往下看，看看 <strong>AllowThousands</strong> 又是如何定义的。</p>
<blockquote>
<p>指示数字字符串可以具有组分隔符，例如将百位与千位分隔开来的符号。 如果 NumberStyles 值包括 AllowCurrencySymbol 标志，要分析的字符串包括货币符号，则有效组分隔符字符由 CurrencyGroupSeparator 属性确定，且每个组中的位数由 CurrencyGroupSizes 属性确定。 否则，有效的组分隔符字符由 NumberGroupSeparator 属性确定，每组的位数由 NumberGroupSizes 属性确定。</p>
</blockquote>
<p>从文档中我们知道每组数字的位数由 <strong>NumberGroupSizes</strong> 来决定。<br>
回过头来继续看刚才反编译的代码，FormatInfo的参数使用的<strong>NumberFormatInfo.CurrentInfo</strong>，现在我们看下<strong>NumberGroupSizes</strong>的值到底是多少（调试发现默认千分位每组的位数是3）。<br>
<img src="https://i.loli.net/2021/02/06/A19HK32ZukCyTOP.png" alt="TryParse示例5.png"></p>
<p>到这里我已经是摸不到头绪了，所以去网上搜索了一下，但是结果也不理想，总结一下网上就两种结论：</p>
<ol>
<li>有逗号时可以转换成功</li>
<li>如果要验证千分位的位置，使用正则来辅助</li>
</ol>
<h2 id="打破砂锅干到底"><a class="header-anchor" href="#打破砂锅干到底">¶</a>打破砂锅干到底</h2>
<p>网上找不到满意的答案，那就只能研究一下.Net的源码了，所以我对 decimal.TryParse 方法进行了调试，终于弄清了这个原因。下面放一部分关键代码：</p>
<p><img src="https://i.loli.net/2021/02/07/v6e721mcqQW5Vgz.png" alt="TryParse示例6.png"><br>
<img src="https://i.loli.net/2021/02/07/zLW6NXwUioxe2af.png" alt="TryParse示例7.png"></p>
<p>实际上在转换的时候，.NET将需要转换的字符串转换成了字符指针，然后一位一位的去做对比。当要对比的字符等于千分位的分隔符时直接跳过，继续对比下一位。因此，不管字符串中有多少个分隔符都是可以转换的，比如下面这个例子：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">decimal</span> <span class="keyword">value</span> = <span class="built_in">decimal</span>.Parse(<span class="string">&quot;1,,,,,,,2,,,,3&quot;</span>);</span><br><span class="line">Console.WriteLine(<span class="keyword">value</span>);</span><br><span class="line"><span class="comment">//输出 123</span></span><br></pre></td></tr></table></figure>
<p>当然，实际上这个转换的过程远比我描述的复杂，我这里只是针对性的分析了一下而已。<br>
至此，整个问题都找到了答案，圆满收官😏😏</p>
]]></content>
      <categories>
        <category>那些年里的那些坑</category>
      </categories>
      <tags>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-简单工厂模式</title>
    <url>/2021/02/18/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>定义</strong> 用单独一个类来创建具体实例的过程。<br>
<strong>类型</strong> 创建型模式<br>
<strong>特点</strong> 使用工厂可以减少代码的耦合性，使代码的可维护性变高。遇到新的需求时，只要新增一个功能的实现，然后通过工厂将实例构建出来即可。<br>
<strong>举例</strong> 实现两个数字的计算，运用工厂分别创建计算加、减、乘、除的不同实例。</p>
<p>本文以C#为例，先来看类图🔻</p>
<a id="more"></a>
<p><img src="https://i.loli.net/2021/02/18/iGabpmZIz6swuX2.jpg" alt="设计模式-简单工厂模式.jpg"><br>
接下来我们来具体分析一下这个类图🔻🔻<br>
定义运算类Operation：该类是一个<strong>抽象类</strong>，拥有NumberA、NumberB两个属性，代表要计算的两个数字；包含一个GetResult的方法，用于对两个数字进行相应的计算。<br>
定义具体的加法类OperationAdd、减法类OperationSub、乘法类OperationMul、除法类OperationDiv：这几个类分别<strong>继承自运算类Operation</strong>，实现具体的计算逻辑。<br>
定义简单工厂类OperationFactory：该类包含一个CreateOperate方法，用于<strong>构造计算时所需要具体的运算类</strong>。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 运算类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Operation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> NumberA &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">double</span> NumberB &#123; <span class="keyword">get</span>; <span class="keyword">set</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">double</span> <span class="title">GetResult</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 加法类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OperationAdd</span> : <span class="title">Operation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">GetResult</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> NumberA + NumberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 减法类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;returns&gt;</span><span class="doctag">&lt;/returns&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OperationSub</span> : <span class="title">Operation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">GetResult</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> NumberA - NumberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 乘法类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OperationMul</span> : <span class="title">Operation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">GetResult</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> NumberA * NumberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 除法类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OperationDiv</span> : <span class="title">Operation</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">GetResult</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> NumberA / NumberB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 简单工厂类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OperationFactory</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Operation <span class="title">CreateOperation</span>(<span class="params"><span class="built_in">string</span> operationType</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (operationType)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;+&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> OperationAdd();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;-&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> OperationSub();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;*&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> OperationMul();</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;/&quot;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> OperationDiv();</span><br><span class="line">            <span class="literal">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;无效的操作符号&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义完需要的代码后，我们来看具体的使用方式🔻</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这里只是演示，不做数据类型的校验</span></span><br><span class="line">Console.WriteLine(<span class="string">&quot;请输入第一个数字：&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> numberA = Console.ReadLine();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;请输入操作符：&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> operationType = Console.ReadLine();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">&quot;请输入第二个数字：&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> numberB = Console.ReadLine();</span><br><span class="line"></span><br><span class="line">Operation operation = <span class="literal">null</span>;</span><br><span class="line">operation = OperationFactory.CreateOperation(operationType);</span><br><span class="line"></span><br><span class="line">operation.NumberA = Convert.ToDouble(numberA);</span><br><span class="line">operation.NumberB = Convert.ToDouble(numberB);</span><br><span class="line"><span class="built_in">double</span> result = operation.GetResult();</span><br><span class="line"></span><br><span class="line">Console.WriteLine(<span class="string">$&quot;计算结果为：<span class="subst">&#123;result&#125;</span>&quot;</span>);</span><br><span class="line">Console.ReadLine();</span><br></pre></td></tr></table></figure>
<p>运行结果如下🔻<br>
<img src="https://i.loli.net/2021/02/19/eKJHmwIdrcquvYE.jpg" alt="CodeResult.jpg"></p>
<p>参考资料：<br>
《大话设计模式》</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>设计模式</tag>
        <tag>简单工厂模式</tag>
        <tag>创建型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-策略模式</title>
    <url>/2021/02/19/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>定义</strong> 策略模式实际上是定义了一系列算法，他们可以相互替换，但是并不影响算法的调用者。<br>
<strong>类型</strong> 行为型模式<br>
<strong>特点</strong> 算法可以相互替换，并不相互影响，具体算法也不会暴露给调用者。<br>
<strong>举例</strong> 超市结账时，使用不同的优惠方式进行结算。</p>
<p>本文以C#为例，先来看类图🔻</p>
<a id="more"></a>
<p><img src="https://i.loli.net/2021/02/19/U6MiXEn1dYmp2Ob.jpg" alt="设计模式-策略模式.jpg"><br>
CashContext主要用于维护一个策略对象。<br>
CashNormal（正常结算）、CashDiscount（折扣结算）、StrategyReturn（满减结算）均继承自CashStrategy，代表具体的策略实现。</p>
<p>这个时候如果又需要开发一个新的结算策略时，只需要继承抽象策略，然后实现新的算法即可。</p>
<p>下面我们来看具体的代码实现🔻</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 策略上下文</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CashContext</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> CashStrategy _cashStrategy;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CashContext</span>(<span class="params">CashStrategy cashStrategy</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _cashStrategy = cashStrategy;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="built_in">double</span> <span class="title">GetResult</span>(<span class="params"><span class="built_in">double</span> money</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">return</span> _cashStrategy.DoCalc(money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 抽象策略</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">CashStrategy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="built_in">double</span> <span class="title">DoCalc</span>(<span class="params"><span class="built_in">double</span> money</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 正常结算策略</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CashNormal</span> : <span class="title">CashStrategy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">DoCalc</span>(<span class="params"><span class="built_in">double</span> money</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//正常结算，不做任何计算</span></span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 折扣结算策略</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CashDiscount</span> : <span class="title">CashStrategy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//要使用的折扣</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">double</span> _discount;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CashDiscount</span>(<span class="params"><span class="built_in">double</span> discount</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _discount = discount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">DoCalc</span>(<span class="params"><span class="built_in">double</span> money</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//折扣结算</span></span><br><span class="line">        <span class="keyword">return</span> money * _discount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 满减结算策略</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">StrategyReturn</span> : <span class="title">CashStrategy</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//满减配置，例如：满200减30</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">double</span> _fullMoney;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> <span class="built_in">double</span> _returnMoney;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StrategyReturn</span>(<span class="params"><span class="built_in">double</span> fullMoney, <span class="built_in">double</span> returnMoney</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _fullMoney = fullMoney;</span><br><span class="line">        _returnMoney = returnMoney;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="built_in">double</span> <span class="title">DoCalc</span>(<span class="params"><span class="built_in">double</span> money</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//满减计算</span></span><br><span class="line">        <span class="keyword">if</span> (money &lt; _fullMoney)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> money;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> money - _returnMoney;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际调用🔻</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="built_in">double</span> money = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">double</span> payment;</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;本次消费金额<span class="subst">&#123;money&#125;</span>元&quot;</span>);</span><br><span class="line">Console.WriteLine(System.Environment.NewLine);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> normalContext = <span class="keyword">new</span> CashContext(<span class="keyword">new</span> CashNormal());</span><br><span class="line">payment = normalContext.GetResult(money);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;正常结算策略，本次需要付款<span class="subst">&#123;payment&#125;</span>元&quot;</span>);</span><br><span class="line">Console.WriteLine(System.Environment.NewLine);</span><br><span class="line"></span><br><span class="line"><span class="comment">//折扣</span></span><br><span class="line"><span class="built_in">double</span> discount = <span class="number">0.8</span>;</span><br><span class="line"><span class="keyword">var</span> discountContext = <span class="keyword">new</span> CashContext(<span class="keyword">new</span> CashDiscount(discount));</span><br><span class="line">payment = discountContext.GetResult(money);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;折扣结算策略，折扣<span class="subst">&#123;discount&#125;</span>，本次需要付款<span class="subst">&#123;payment&#125;</span>元&quot;</span>);</span><br><span class="line">Console.WriteLine(System.Environment.NewLine);</span><br><span class="line"></span><br><span class="line"><span class="comment">//满100-50</span></span><br><span class="line"><span class="built_in">double</span> fullMoney = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">double</span> returnMoney = <span class="number">50</span>;</span><br><span class="line"><span class="keyword">var</span> returnContext = <span class="keyword">new</span> CashContext(<span class="keyword">new</span> StrategyReturn(fullMoney, returnMoney));</span><br><span class="line">payment = returnContext.GetResult(money);</span><br><span class="line">Console.WriteLine(<span class="string">$&quot;满减结算策略，满<span class="subst">&#123;fullMoney&#125;</span>减<span class="subst">&#123;returnMoney&#125;</span>，本次需要付款<span class="subst">&#123;payment&#125;</span>元&quot;</span>);</span><br><span class="line">Console.WriteLine(System.Environment.NewLine);</span><br><span class="line"></span><br><span class="line">Console.ReadLine();</span><br></pre></td></tr></table></figure>
<p>运行结果🔻<br>
<img src="https://i.loli.net/2021/02/19/FmEoGBkPfVCJjtp.jpg" alt="CodeResult.jpg"></p>
<p>参考资料：<br>
《大话设计模式》</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>设计模式</tag>
        <tag>策略模式</tag>
        <tag>行为型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-代理模式</title>
    <url>/2021/02/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><strong>定义</strong> 为其他对象提供一个代理通道，来完成对这个对象的访问。<br>
<strong>类型</strong> 结构型模式<br>
<strong>特点</strong> 可以对调用者隐藏实际对象。<br>
<strong>举例</strong> 张三替李四追求王五。</p>
<p>本文以C#为例，先来看类图🔻</p>
<a id="more"></a>
<p><img src="https://i.loli.net/2021/02/23/D3Xc2YAfgM9OJer.jpg" alt="设计模式-代理模式.jpg"></p>
<p>代理模式还是相对比较简单和容易理解的，所以我们直接看具体的代码实现🔻</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 定义一个代理和真实类共用的接口</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">LoveBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">SendLove</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 代理类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ProxyLove</span> : <span class="title">LoveBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> RealLove _realLove;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">SendLove</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">//初始化真实的表白对象，并调用真实的表白方法</span></span><br><span class="line">        _realLove ??= <span class="keyword">new</span> RealLove();</span><br><span class="line">        _realLove.SendLove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 真实的表白类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">RealLove</span> : <span class="title">LoveBase</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">void</span> <span class="title">SendLove</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;张三真实的表白&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment">//客户端调用</span></span><br><span class="line">LoveBase love = <span class="keyword">new</span> ProxyLove();</span><br><span class="line">love.SendLove();</span><br><span class="line"><span class="comment">//结果输出 张三真实的表白</span></span><br></pre></td></tr></table></figure>
<p>参考资料：<br>
《大话设计模式》</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>设计模式</tag>
        <tag>代理模式</tag>
        <tag>结构型模式</tag>
      </tags>
  </entry>
  <entry>
    <title>C#线程同步构造</title>
    <url>/2021/03/01/C-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9E%84%E9%80%A0/</url>
    <content><![CDATA[<p>我们都知道，程序在运行时，不同线程访问同一个对象，是非常常见的事情。这种情况下如果处理不当，那么就会造成与预期不符的结果，所以线程同步在程序里有着相当重要的作用。<br>
下面我们来看下常用的一些线程同步的方式方法。🔻</p>
<a id="more"></a>
<h2 id="易变构造-volatile"><a class="header-anchor" href="#易变构造-volatile">¶</a>易变构造 volatile</h2>
<p><strong>volatile</strong> 关键字指示一个字段可以由多个同时执行的线程修改，通过 <strong>volatile</strong> 关键字，可以保证变量在执行上有着原子性的读、写操作。<br>
<strong>volatile</strong> 关键字可应用于以下类型的字段：</p>
<ul>
<li>引用类型。</li>
<li>指针类型（在不安全的上下文中）。 请注意，虽然指针本身可以是可变的，但是它指向的对象不能是可变的。 换句话说，不能声明“指向可变对象的指针”。</li>
<li>简单类型，如 sbyte、byte、short、ushort、int、uint、char、float 和 bool。</li>
<li>具有以下基本类型之一的 enum 类型：byte、sbyte、short、ushort、int 或 uint。</li>
<li>已知为引用类型的泛型类型参数。</li>
<li>IntPtr 和 UIntPtr。</li>
</ul>
<p>这些描述读起来比较绕口，那么我们通过一个示例来演示以下 <strong>volatile</strong> 的基本用法。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;summary&gt;</span></span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> 定义测试类</span></span><br><span class="line"><span class="comment"><span class="doctag">///</span> <span class="doctag">&lt;/summary&gt;</span></span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">VolatileTest</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">bool</span> _isStop = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Do</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;任务开始&quot;</span>);</span><br><span class="line">        <span class="keyword">var</span> th = <span class="keyword">new</span> Thread(Thread1);</span><br><span class="line">        th.Start();</span><br><span class="line"></span><br><span class="line">        Thread.Sleep(<span class="number">5000</span>);</span><br><span class="line">        _isStop = <span class="literal">true</span>;</span><br><span class="line">        Console.WriteLine(<span class="string">&quot;等待任务完成&quot;</span>);</span><br><span class="line">        th.Join();</span><br><span class="line"></span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Thread1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="built_in">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!_isStop)</span><br><span class="line">        &#123;</span><br><span class="line">            x = x + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine(<span class="string">$&quot;任务执行完成，计数：<span class="subst">&#123;x&#125;</span>&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="built_in">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//调用测试方法</span></span><br><span class="line">    <span class="keyword">new</span> VolatileTest().Do();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先来猜猜上面这段代码的执行结果是怎样的😓😓</p>
<p>代码在编译时，根据不同的编译配置，可能会出现不同的结果。</p>
<ul>
<li>
<p>在Debug模式下，编译器并没有对代码进行优化，所以程序会得到正常的执行结果🔻<br>
<img src="https://i.loli.net/2021/03/01/PvKmZLhQNtl2uM1.jpg" alt="VolatileDebug.jpg"><br>
<em>至于这里的计数为什么会是负数，这个以后有机会在单独写文章分析</em></p>
</li>
<li>
<p>在Release模式下,编译器默认打开了代码优化功能。编译VolatileTest文件时，编译器发现_isStop在Thread1方法中并不会发生改变，并且<strong>对_isStop的检查只会在循环前发生一次，不会每次循环时都检查</strong>。因此会生成一段一直累加x的代码出来。因此，程序运行时，得到了以下结果🔻<br>
<img src="https://i.loli.net/2021/03/01/qkXNTVtiIhaplEu.jpg" alt="VolatileRelease.jpg"></p>
</li>
</ul>
<p>接下来通过IL代码来对比一下两者的不同（左边为Debug版本，右边为Release版本）<br>
<img src="https://i.loli.net/2021/03/01/6GfIXBDxwCpRQkM.jpg" alt="VolatileIL.jpg"><br>
在两个版本中，主要有两点不同：</p>
<ol>
<li>Debug版本中，在初始化变量时，定义了一个bool类型的变量；Release版本没有</li>
<li>Debug版本中，在循环结束前，对定义的bool变量和_isStop进行了计算，然后判断是否需要继续循环；Release版本中直接获取并校验了_isStop的值，结果为false，则无限循环。</li>
</ol>
<p>要解决这个问题其实很简单，就是使用前面所说的<strong>Volatile</strong>关键字定义变量即可。<strong>Volatile</strong>能保证变量的原子操作，因此用<strong>Volatile</strong>定义的变量，编译器是不会进行之前的优化操作。<br>
所以重新修改_isStop变量的定义即可修正前面的问题。</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="built_in">bool</span> _isStop = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>
<p>另外，Volatile类还提供了以下两个静态方法来进行变量的读写🔻</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line">Volatile.Read(<span class="keyword">ref</span> _isStop);</span><br><span class="line">Volatile.Write(<span class="keyword">ref</span> _isStop,<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>因此通过如下代码也可以修正前面的问题：</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Thread1</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">int</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//这里使用Volatile.Read来读取最新的值</span></span><br><span class="line">    <span class="keyword">while</span> (!Volatile.Read(<span class="keyword">ref</span> _isStop))</span><br><span class="line">    &#123;</span><br><span class="line">        x = x + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Console.WriteLine(<span class="string">$&quot;任务执行完成，计数：<span class="subst">&#123;x&#125;</span>&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果对上面的概念还是不太理解，那么可以再参考下书中的这样一段定义🔻</p>
<blockquote>
<p>当线程通过共享内存相互通信时，调用Volatile.Write来写入最后一个值，调用Volatile.Read来读取第一个值</p>
</blockquote>
<p>参考资料：<br>
《CLR via C#》<br>
<a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/keywords/volatile?f1url=%3FappId%3DDev16IDEF1%26l%3DZH-CN%26k%3Dk(volatile_CSharpKeyword);k(TargetFrameworkMoniker-.NETFramework,Version%253Dv4.5);k(DevLang-csharp)%26rd%3Dtrue">MSDN</a></p>
<p><em><strong>本文未完，后面还会持续更新，学一点总结一点</strong></em>🐶🐶</p>
]]></content>
      <categories>
        <category>.NET</category>
      </categories>
      <tags>
        <tag>线程同步</tag>
        <tag>Volatile</tag>
      </tags>
  </entry>
</search>
